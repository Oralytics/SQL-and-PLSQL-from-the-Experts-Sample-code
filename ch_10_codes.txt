—-
—- Real World SQL and PL/SQL from the Experts
—-    Published by : McGraw-Hill / Oracle Press
—-
—- Chapter 10 - Sample Code Listing
—-

column model_name format a25SELECT model_name,        algorithm,        build_duration,        model_size FROM  ALL_MINING_MODELSWHERE mining_function = 'CLASSIFICATION';SELECT count(*)FROM   mining_data_build_vSAMPLE (20);SELECT count(*)FROM   mining_data_build_vSAMPLE BLOCK (20);SELECT count(*)FROM   mining_data_build_vSAMPLE (20) SEED (124);create view BUILD_DATA_SET_Vas SELECT * FROM   mining_data_build_vWHERE ORA_HASH(CUST_ID, 99, 0) <= 60;create view TEST_DATA_SET_Vas SELECT * FROM   mining_data_build_vWHERE ORA_HASH(CUST_ID, 99, 0) > 60;-- Transform missing data for numeric attributesBEGIN   --   -- Clean-up : Drop the previously created tables   --   BEGIN      execute immediate 'drop table TRANSFORM_MISSING_NUMERIC';   EXCEPTION       WHEN others THEN         null;   END;   BEGIN      execute immediate 'drop table TRANSFORM_MISSING_CATEGORICAL';   EXCEPTION       WHEN others THEN         null;   END;   --    -- Transform the numeric attributes   --   dbms_data_mining_transform.CREATE_MISS_NUM (      miss_table_name => 'TRANSFORM_MISSING_NUMERIC');   dbms_data_mining_transform.INSERT_MISS_NUM_MEAN (    miss_table_name => 'TRANSFORM_MISSING_NUMERIC',    data_table_name => 'MINING_DATA_BUILD_V',    exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (                       'affinity_card',                       'cust_id'));   --   -- Transform the categorical attributes   --   dbms_data_mining_transform.CREATE_MISS_CAT (      miss_table_name => 'TRANSFORM_MISSING_CATEGORICAL');   dbms_data_mining_transform.INSERT_MISS_CAT_MODE (      miss_table_name => 'TRANSFORM_MISSING_CATEGORICAL',      data_table_name => 'MINING_DATA_BUILD_V',      exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (                         'affinity_card',                         'cust_id'));END;/column col format a25column val format a25SELECT col, val FROM   transform_missing_categorical;BEGIN   -- xform input data to replace missing values   -- The data source is MINING_DATA_BUILD_V   -- The output is MINING_DATA_MISS_V   DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_NUM(      miss_table_name => 'TRANSFORM_MISSING_NUMERIC',      data_table_name => 'MINING_DATA_BUILD_V',      xform_view_name => 'MINING_DATA_MISS_V');   -- xform input data to replace missing values   -- The data source is MINING_DATA_MISS_V   -- The output is MINING_DATA_V   DBMS_DATA_MINING_TRANSFORM.XFORM_MISS_CAT(      miss_table_name => 'TRANSFORM_MISSING_CATEGORICAL',      data_table_name => 'MINING_DATA_MISS_V',      xform_view_name => 'MINING_DATA_V');END;/BEGIN   -- Clean-up : Drop the previously created tables   BEGIN      execute immediate 'drop table TRANSFORM_OUTLIER';   EXCEPTION       WHEN others THEN         null;   END;   -- Stage 1 : Create the table for the transformations   -- Perform outlier treatment for: AGE and YRS_RESIDENCE   --    DBMS_DATA_MINING_TRANSFORM.CREATE_CLIP (      clip_table_name => 'TRANSFORM_OUTLIER');   -- Stage 2 : Transform the categorical attributes   --   Exclude the number attributes you do not want transformed   DBMS_DATA_MINING_TRANSFORM.INSERT_CLIP_WINSOR_TAIL (      clip_table_name => 'TRANSFORM_OUTLIER',      data_table_name => 'MINING_DATA_V',      tail_frac       => 0.025,      exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (                          'affinity_card',                          'bookkeeping_application',                          'bulk_pack_diskettes',                          'cust_id',                          'flat_panel_monitor',                          'home_theater_package',                          'os_doc_set_kanji',                          'printer_supplies',                          'y_box_games'));   -- Stage 3 : Create the view with the transformed data   DBMS_DATA_MINING_TRANSFORM.XFORM_CLIP(      clip_table_name => 'TRANSFORM_OUTLIER',      data_table_name => 'MINING_DATA_V',      xform_view_name => 'MINING_DATA_V_2');END;/BEGIN   -- Clean-up : Drop the previously created tables   BEGIN      execute immediate 'drop table TRANSFORM_NORMALIZE';   EXCEPTION       WHEN others THEN         null;   END;   -- Stage 1 : Create the table for the transformations   -- Perform normalization for: AGE and YRS_RESIDENCE   dbms_data_mining_transform.CREATE_NORM_LIN (      norm_table_name => 'MINING_DATA_NORMALIZE');           -- Step 2 : Insert the normalization data into the table   dbms_data_mining_transform.INSERT_NORM_LIN_MINMAX (      norm_table_name => 'MINING_DATA_NORMALIZE',      data_table_name => 'MINING_DATA_V_2',      exclude_list    => DBMS_DATA_MINING_TRANSFORM.COLUMN_LIST (                         'affinity_card',                         'bookkeeping_application',                         'bulk_pack_diskettes',                         'cust_id',                         'flat_panel_monitor',                         'home_theater_package',                         'os_doc_set_kanji',                         'printer_supplies',                         'y_box_games'));   -- Stage 3 : Create the view with the transformed data   DBMS_DATA_MINING_TRANSFORM.XFORM_NORM_LIN (      norm_table_name => 'MINING_DATA_NORMALIZE',      data_table_name => 'MINING_DATA_V_2',      xform_view_name => 'MINING_DATA_READY_V');END;/-- create the settings table for a Decision Tree modelCREATE TABLE demo_class_dt_settings ( setting_name  VARCHAR2(30),  setting_value VARCHAR2(4000));-- insert the settings records for a Decision Tree-- Decision Tree algorithm. By Default Naive Bayes is used for classification-- ADP is turned on. By default ADP is turned off.BEGIN  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  values (dbms_data_mining.algo_name, dbms_data_mining.algo_decision_tree);	  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  VALUES (dbms_data_mining.prep_auto,dbms_data_mining.prep_auto_on);END;/BEGIN    DBMS_DATA_MINING.CREATE_MODEL(       model_name 			=> 'DEMO_CLASS_DT_MODEL',       mining_function 		=> dbms_data_mining.classification,       data_table_name 		=> 'MINING_DATA_READY_V',       case_id_column_name 	=> 'cust_id',       target_column_name 	=> 'affinity_card',       settings_table_name 	=> 'demo_class_dt_settings'); END;/DECLARE   transform_stack   dbms_data_mining_transform.TRANSFORM_LIST;BEGIN   dbms_data_mining_transform.SET_TRANSFORM(transform_stack,                                             'BOOKKEEPING_APPLICATION',                                             NULL,                                             'to_char(BOOKKEEPING_APPLICATION)',                                             'to_number(BOOKKEEPING_APPLICATION)',                                             NULL); END;/DECLARE   transform_stack   dbms_data_mining_transform.TRANSFORM_LIST;BEGIN   -- Define the transformation list   dbms_data_mining_transform.SET_TRANSFORM(transform_stack,                                             'BOOKKEEPING_APPLICATION',                                             NULL,                                             'to_char(BOOKKEEPING_APPLICATION)',                                             'to_number(BOOKKEEPING_APPLICATION)',                                             NULL);    -- Create the data mining model   DBMS_DATA_MINING.CREATE_MODEL(       model_name 		=> 'DEMO_TRANSFORM_MODEL',       mining_function 		=> dbms_data_mining.classification,       data_table_name 		=> 'MINING_DATA_BUILD_V',       case_id_column_name 	=> 'cust_id',       target_column_name 	=> 'affinity_card',       settings_table_name 	=> 'demo_class_dt_settings',      xform_list              => transform_stack); END;/DECLARE   transform_stack   dbms_data_mining_transform.TRANSFORM_LIST;BEGIN   -- Stack the missing numeric transformations   dbms_data_mining_transform.STACK_MISS_NUM (          miss_table_name   => 'TRANSFORM_MISSING_NUMERIC',          xform_list        => transform_stack);   -- Stack the missing categorical transformations   dbms_data_mining_transform.STACK_MISS_CAT (          miss_table_name   => 'TRANSFORM_MISSING_CATEGORICAL',          xform_list        => transform_stack);   -- Stack the outlier treatment for AGE   dbms_data_mining_transform.STACK_CLIP (          clip_table_name   => 'TRANSFORM_OUTLIER',          xform_list        => transform_stack);   -- Stack the normalization transformation   dbms_data_mining_transform.STACK_NORM_LIN (          norm_table_name   => 'MINING_DATA_NORMALIZE',          xform_list        => transform_stack);   -- Create the data mining model   DBMS_DATA_MINING.CREATE_MODEL(       model_name 		=> 'DEMO_STACKED_MODEL',       mining_function 	=> dbms_data_mining.classification,       data_table_name 	=> 'MINING_DATA_BUILD_V',       case_id_column_name 	=> 'cust_id',       target_column_name 	=> 'affinity_card',       settings_table_name 	=> 'demo_class_dt_settings',      xform_list           => transform_stack); END;/SELECT TO_CHAR(expression) FROM TABLE(dbms_data_mining.GET_MODEL_TRANSFORMATIONS('DEMO_STACKED_MODEL'));-- create the settings table for a Decision Tree modelDROP TABLE demo_class_dt_settings;
CREATE TABLE demo_class_dt_settings ( setting_name  VARCHAR2(30),  setting_value VARCHAR2(4000));-- insert the settings records for a Decision Tree-- Decision Tree algorithm. By Default Naive Bayes is used for classification-- ADP is turned on. By default ADP is turned off.BEGIN  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  values (dbms_data_mining.algo_name, dbms_data_mining.algo_decision_tree);	  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  VALUES (dbms_data_mining.prep_auto,dbms_data_mining.prep_auto_on);END;/-- create the settings table for a Decision Tree modelDROP TABLE demo_class_dt_settings;
CREATE TABLE demo_class_dt_settings ( setting_name  VARCHAR2(30),  setting_value VARCHAR2(4000));-- insert the settings records for a Decision Tree-- Decision Tree algorithm. By Default Naive Bayes is used for classification-- ADP is turned on. By default ADP is turned off.BEGIN  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  values (dbms_data_mining.algo_name, dbms_data_mining.algo_decision_tree);	  INSERT INTO demo_class_dt_settings (setting_name, setting_value)  VALUES (dbms_data_mining.prep_auto,dbms_data_mining.prep_auto_on);END;/SELECT *FROM   demo_class_dt_settings;BEGIN    DBMS_DATA_MINING.CREATE_MODEL(       model_name 		=> 'DEMO_CLASS_DT_MODEL',       mining_function 		=> dbms_data_mining.classification,       data_table_name 		=> 'mining_data_build_v',       case_id_column_name 	=> 'cust_id',       target_column_name 	=> 'affinity_card',       settings_table_name 	=> 'demo_class_dt_settings'); END;/-- create the settings table for a Support Vector Machine modelCREATE TABLE demo_class_svm_settings ( setting_name  VARCHAR2(30),  setting_value VARCHAR2(4000));-- insert the settings records for a Support Vector Machine-- Support Vector Machine algorithm. By Default Naive Bayes is used for classification-- ADP is turned on. By default ADP is turned off.BEGIN  INSERT INTO demo_class_svm_settings (setting_name, setting_value)  values (dbms_data_mining.algo_name,dbms_data_mining.algo_support_vector_machines);  INSERT INTO demo_class_svm_settings (setting_name, setting_value)  VALUES (dbms_data_mining.prep_auto,dbms_data_mining.prep_auto_on);END;/BEGIN    DBMS_DATA_MINING.CREATE_MODEL(       model_name 		=> 'DEMO_CLASS_SVM_MODEL',       mining_function 		=> dbms_data_mining.classification,       data_table_name 		=> 'mining_data_build_v',       case_id_column_name 	=> 'cust_id',       target_column_name 	=> 'affinity_card',       settings_table_name 	=> 'demo_class_svm_settings'); END;/SELECT model_name,        algorithm,        build_duration,        model_size FROM ALL_MINING_MODELSWHERE mining_function = 'CLASSIFICATION';SELECT setting_name,        setting_value,        setting_type FROM  all_mining_model_settings WHERE model_name = 'DEMO_CLASS_DT_MODEL';SELECT attribute_name,        attribute_type,        usage_type,        target FROM  all_mining_model_attributes WHERE model_name = 'DEMO_CLASS_DT_MODEL';  CREATE OR REPLACE VIEW demo_class_dt_test_resultASSELECT cust_id,       prediction(DEMO_CLASS_DT_MODEL USING *)  predicted_value,       prediction_probability(DEMO_CLASS_DT_MODEL USING *) probabilityFROM   mining_data_test_v;SELECT * FROM demo_class_dt_test_resultFETCH first 8 rows only;DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (    accuracy 				OUT NUMBER,    apply_result_table_name 		IN VARCHAR2,    target_table_name 			IN VARCHAR2,    case_id_column_name 		IN VARCHAR2,    target_column_name 			IN VARCHAR2,    confusion_matrix_table_name 	IN VARCHAR2,    score_column_name 			IN VARCHAR2 DEFAULT 'PREDICTION',    score_criterion_column_name 	IN VARCHAR2 DEFAULT 'PROBABILITY',    cost_matrix_table_name 		IN VARCHAR2 DEFAULT NULL,    apply_result_schema_name 		IN VARCHAR2 DEFAULT NULL,    target_schema_name 			IN VARCHAR2 DEFAULT NULL,    cost_matrix_schema_name 		IN VARCHAR2 DEFAULT NULL,    score_criterion_type 		IN VARCHAR2 DEFAULT 'PROBABILITY');set serveroutput onDECLARE   v_accuracy NUMBER;BEGIN   DBMS_DATA_MINING.COMPUTE_CONFUSION_MATRIX (      accuracy 			    => v_accuracy,      apply_result_table_name	    => 'demo_class_dt_test_result',      target_table_name 	    => 'mining_data_test_v',      case_id_column_name 	    => 'cust_id',      target_column_name 	    => 'affinity_card',      confusion_matrix_table_name   => 'demo_class_dt_confusion_matrix',      score_column_name 	    => 'PREDICTED_VALUE',      score_criterion_column_name   => 'PROBABILITY',      cost_matrix_table_name	    => null,      apply_result_schema_name      => null,      target_schema_name 	    => null,      cost_matrix_schema_name       => null,      score_criterion_type 	    => 'PROBABILITY');   DBMS_OUTPUT.PUT_LINE('**** MODEL ACCURACY ****: ' || ROUND(v_accuracy,4));END;/SELECT * FROM   demo_class_dt_confusion_matrix;DBMS_DATA_MINING.COMPUTE_LIFT (   apply_result_table_name 	 IN VARCHAR2,   target_table_name 		 IN VARCHAR2,   case_id_column_name 		 IN VARCHAR2,   target_column_name 		 IN VARCHAR2,   lift_table_name 		 IN VARCHAR2,   positive_target_value 	 IN VARCHAR2,   score_column_name 		 IN VARCHAR2 DEFAULT 'PREDICTION',   score_criterion_column_name   IN VARCHAR2 DEFAULT 'PROBABILITY',   num_quantiles 		 IN NUMBER DEFAULT 10,   cost_matrix_table_name 	 IN VARCHAR2 DEFAULT NULL,   apply_result_schema_name 	 IN VARCHAR2 DEFAULT NULL,   target_schema_name 		 IN VARCHAR2 DEFAULT NULL,   cost_matrix_schema_name 	 IN VARCHAR2 DEFAULT NULL   score_criterion_type 	 IN VARCHAR2 DEFAULT 'PROBABILITY');BEGIN   DBMS_DATA_MINING.COMPUTE_LIFT (      apply_result_table_name    => 'demo_class_dt_test_result',      target_table_name 	 => 'mining_data_test_v',      case_id_column_name 	 => 'cust_id',      target_column_name 	 => 'affinity_card',      lift_table_name 		 => 'DEMO_CLASS_DT_LIFT',      positive_target_value 	 => '1',      score_column_name 	 => 'PREDICTED_VALUE',      score_criterion_column_name => 'PROBABILITY',      num_quantiles 		 => 10,      cost_matrix_table_name 	 => null,      apply_result_schema_name 	 => null,      target_schema_name 	 => null,      cost_matrix_schema_name    => null,      score_criterion_type 	 => 'PROBABILITY');END;/SELECT quantile_number,        probability_threshold,        gain_cumulative,       quantile_total_countFROM   demo_class_dt_lift;DBMS_DATA_MINING.COMPUTE_ROC (   roc_area_under_curve 	 OUT NUMBER,   apply_result_table_name 	 IN VARCHAR2,   target_table_name 		 IN VARCHAR2,   case_id_column_name 		 IN VARCHAR2,   target_column_name 		 IN VARCHAR2,   roc_table_name 		 IN VARCHAR2,   positive_target_value 	 IN VARCHAR2,   score_column_name 		 IN VARCHAR2 DEFAULT 'PREDICTION',   score_criterion_column_name   IN VARCHAR2 DEFAULT 'PROBABILITY',   apply_result_schema_name 	 IN VARCHAR2 DEFAULT NULL,   target_schema_name 		 IN VARCHAR2 DEFAULT NULL);set serveroutput onDECLARE   v_area_under_curve NUMBER;BEGIN   DBMS_DATA_MINING.COMPUTE_ROC (      roc_area_under_curve 	  => v_area_under_curve,      apply_result_table_name     => 'demo_class_dt_test_result',      target_table_name 	  => 'mining_data_test_v',      case_id_column_name 	  => 'cust_id',      target_column_name 	  => 'affinity_card',      roc_table_name 		  => 'DEMO_CLASS_DT_ROC',      positive_target_value  	  => '1',      score_column_name 	  => 'PREDICTED_VALUE',      score_criterion_column_name => 'PROBABILITY');   DBMS_OUTPUT.PUT_LINE('**** AREA UNDER ROC CURVE ****: ' ||       ROUND(v_area_under_curve,4));END;/SELECT probability,        true_positive_fraction,        false_positive_fractionFROM   demo_class_dt_roc;DBMS_DATA_MINING.APPLY (   model_name 		 IN VARCHAR2,   data_table_name 	 IN VARCHAR2,   case_id_column_name   IN VARCHAR2,   result_table_name 	 IN VARCHAR2,   data_schema_name 	 IN VARCHAR2 DEFAULT NULL);BEGIN   dbms_data_mining.APPLY(model_name          => 'DEMO_CLASS_DT_MODEL',                          data_table_name     => 'MINING_DATA_APPLY_V',                          case_id_column_name => 'CUST_ID',                          result_table_name   => 'DEMO_DT_DATA_SCORED'); END; /SELECT * FROM   demo_dt_data_scoredFETCH first 10 rows only;SELECT cust_id, PREDICTION(DEMO_CLASS_DT_MODEL USING *) FROM   mining_data_apply_vFETCH first 8 rows only;SELECT cust_id FROM   mining_data_apply_vWHERE  PREDICTION(DEMO_CLASS_DT_MODEL USING *) = 1 FETCH first 8 rows only;SELECT cust_id,        PREDICTION(DEMO_CLASS_DT_MODEL USING *) Predicted_Value,       PREDICTION_PROBABILITY(DEMO_CLASS_DT_MODEL USING *) ProbFROM   mining_data_apply_vFETCH first 8 rows only;SELECT prediction(DEMO_CLASS_DT_MODEL     USING 'F' AS cust_gender,            62 AS age,       'Widowed' AS cust_marital_status,            'Exec.' as occupation,            2 as household_size,            3 as yrs_residence)  Predicted_Value,       prediction_probability(DEMO_CLASS_DT_MODEL, 0     USING 'F' AS cust_gender,            62 AS age,       'Widowed' AS cust_marital_status,            'Exec.' as occupation,            2 as household_size,            3 as yrs_residence) Predicted_ProbFROM dual;SELECT PREDICTION(DEMO_CLASS_DT_MODEL using AGE) Pred_Value2,       prediction_probability (DEMO_CLASS_DT_MODEL using AGE) Pred_Prob2,       PREDICTION(DEMO_CLASS_DT_MODEL using AGE, HOUSEHOLD_SIZE) Pred_Value3,       prediction_probability (DEMO_CLASS_DT_MODEL using AGE, HOUSEHOLD_SIZE) Pred_Prob3,       PREDICTION(DEMO_CLASS_DT_MODEL using AGE, HOUSEHOLD_SIZE, EDUCATION) Pred_Value4,       prediction_probability (DEMO_CLASS_DT_MODEL using AGE, HOUSEHOLD_SIZE, EDUCATION) Pred_Prob4,       PREDICTION(DEMO_CLASS_DT_MODEL using *) Pred_Value,       prediction_probability (DEMO_CLASS_DT_MODEL using *) Pred_Prob FROM  MINING_DATA_BUILD_VWHERE cust_id = 101504;